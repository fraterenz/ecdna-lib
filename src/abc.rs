use anyhow::Context;
use derive_builder::Builder;
use serde::Serialize;
use std::fs;
use std::path::Path;

use crate::distribution::EcDNADistribution;

/// The data used to perform ABC.
#[derive(Debug)]
pub struct Data {
    pub distribution: Option<EcDNADistribution>,
    pub mean: Option<f32>,
    pub frequency: Option<f32>,
    pub entropy: Option<f32>,
}

/// Perform the ABC rejection algorithm for one run to infer the most probable
/// values of the rates based on the patient's data.
///
/// ABC infer the most probable values of the birth-death rates (proliferation
/// rates and death rates) by comparing the summary statistics of the run
/// generated by the birth-death process against the summary statistics of the
/// patient's data.
///
/// When testing multiple statistics with ABC, save runs only if all statistics
/// pass the tests
pub struct ABCRejection;

impl ABCRejection {
    pub fn run(
        mut builder: ABCResultBuilder,
        distribution: &EcDNADistribution,
        target: &Data,
        verbosity: u8,
    ) -> ABCResult {
        //! Run the ABC rejection method by comparing a ecDNA `distribution`
        //! against the `target`.
        let pop_size = distribution.get_nminus() + distribution.compute_nplus();
        builder.pop_size(pop_size);
        let ecdna_stat = if let Some(target_distribution) = &target.distribution {
            let (distance, convergence) = target_distribution.ks_distance(distribution);
            if convergence {
                Some(distance)
            } else {
                println!("DID NOT CONVERGE!");
                None
            }
        } else {
            None
        };
        builder.ecdna_stat(ecdna_stat);

        let mean = distribution.compute_mean();
        builder.mean(mean);
        let mean_stat = target
            .mean
            .as_ref()
            .map(|target_mean| relative_change(target_mean, &mean));
        builder.mean_stat(mean_stat);

        let frequency = distribution.compute_frequency();
        builder.frequency(frequency);
        let frequency_stat = target
            .frequency
            .as_ref()
            .map(|target_frequency| relative_change(target_frequency, &frequency));
        builder.frequency_stat(frequency_stat);

        let entropy = distribution.compute_entropy();
        builder.entropy(entropy);
        let entropy_stat = target
            .entropy
            .as_ref()
            .map(|target_entropy| relative_change(target_entropy, &entropy));
        builder.entropy_stat(entropy_stat);

        if verbosity > 0 {
            println!(
                "The stats are: ks:{:#?}, mean: {:#?}, freq: {:#?}, entropy: {:#?}",
                ecdna_stat, mean_stat, frequency_stat, entropy_stat
            );
        }

        builder.build().expect("Cannot build ABC results")
    }
}

#[derive(Builder, Debug, Serialize)]
pub struct ABCResult {
    pub idx: usize,
    pub mean: f32,
    #[builder(default)]
    pub mean_stat: Option<f32>,
    pub frequency: f32,
    #[builder(default)]
    pub frequency_stat: Option<f32>,
    pub entropy: f32,
    #[builder(default)]
    pub entropy_stat: Option<f32>,
    #[builder(default)]
    pub ecdna_stat: Option<f32>,
    pub b0: f32,
    pub b1: f32,
    pub pop_size: u64,
}

impl ABCResult {
    pub fn save(&self, path2folder: &Path, verbosity: u8) -> anyhow::Result<()> {
        if verbosity > 0 {
            println!(
                "Statistics of the run: Mean: {}, Freq: {}, Entropy: {}",
                self.mean, self.frequency, self.entropy
            );
        }
        fs::create_dir_all(path2folder.join("abc"))
            .with_context(|| "Cannot create dir abc".to_string())?;
        let mut abc = path2folder.join("abc").join(self.idx.to_string());
        abc.set_extension("csv");
        if verbosity > 1 {
            println!("Saving ABC results to {:#?}", abc);
        }
        let mut wtr = csv::Writer::from_path(abc)?;
        wtr.serialize(&self)
            .with_context(|| "Cannot serialize the results from ABC inference".to_string())?;
        wtr.flush()?;
        Ok(())
    }
}

/// Relative change between two scalars
pub fn relative_change(x1: &f32, &x2: &f32) -> f32 {
    (x1 - x2).abs() / x1
}

#[cfg(test)]
mod tests {
    use quickcheck_macros::quickcheck;

    use crate::test_util::NonEmptyDistribtionWithNPlusCells;

    use super::*;

    #[quickcheck]
    fn abc_run_test(
        distribution: NonEmptyDistribtionWithNPlusCells,
        idx: usize,
        b0: f32,
        b1: f32,
    ) -> bool {
        let mut builder = ABCResultBuilder::default();
        builder.idx(idx);
        builder.b0(b0);
        builder.b1(b1);
        let mean = distribution.0.compute_mean();
        let frequency = distribution.0.compute_frequency();
        let entropy = distribution.0.compute_entropy();
        builder.mean(mean);
        builder.frequency(frequency);
        builder.entropy(entropy);
        let target = Data {
            distribution: Some(distribution.0.clone()),
            mean: Some(mean),
            frequency: Some(frequency),
            entropy: Some(entropy),
        };

        let results = ABCRejection::run(builder, &distribution.0, &target, 0);
        (results.ecdna_stat.unwrap() - 0f32).abs() < f32::EPSILON
            && (results.mean_stat.unwrap() - 0f32).abs() < f32::EPSILON
            && (results.frequency_stat.unwrap() - 0f32).abs() < f32::EPSILON
            && (results.entropy_stat.unwrap() - 0f32).abs() < 10f32 * f32::EPSILON
    }

    #[quickcheck]
    fn abc_run_no_distribution_test(
        distribution: NonEmptyDistribtionWithNPlusCells,
        idx: usize,
        b0: f32,
        b1: f32,
    ) -> bool {
        let mut builder = ABCResultBuilder::default();
        builder.idx(idx);
        builder.b0(b0);
        builder.b1(b1);
        let mean = distribution.0.compute_mean();
        let frequency = distribution.0.compute_frequency();
        let entropy = distribution.0.compute_entropy();
        builder.mean(mean);
        builder.frequency(frequency);
        builder.entropy(entropy);
        let target = Data {
            distribution: None,
            mean: Some(mean),
            frequency: Some(frequency),
            entropy: Some(entropy),
        };

        let results = ABCRejection::run(builder, &distribution.0, &target, 0);
        results.ecdna_stat.is_none()
            && (results.mean_stat.unwrap() - 0f32).abs() < f32::EPSILON
            && (results.frequency_stat.unwrap() - 0f32).abs() < f32::EPSILON
            && (results.entropy_stat.unwrap() - 0f32).abs() < 10f32 * f32::EPSILON
    }
    #[quickcheck]
    fn abc_run_distribution_only_test(
        distribution: NonEmptyDistribtionWithNPlusCells,
        idx: usize,
        b0: f32,
        b1: f32,
    ) -> bool {
        let mut builder = ABCResultBuilder::default();
        builder.idx(idx);
        builder.b0(b0);
        builder.b1(b1);
        let mean = distribution.0.compute_mean();
        let frequency = distribution.0.compute_frequency();
        let entropy = distribution.0.compute_entropy();
        builder.mean(mean);
        builder.frequency(frequency);
        builder.entropy(entropy);
        let target = Data {
            distribution: Some(distribution.0.clone()),
            mean: None,
            frequency: None,
            entropy: None,
        };

        let results = ABCRejection::run(builder, &distribution.0, &target, 0);
        (results.ecdna_stat.unwrap() - 0f32).abs() < f32::EPSILON
            && results.mean_stat.is_none()
            && results.frequency_stat.is_none()
            && results.entropy_stat.is_none()
    }
}
